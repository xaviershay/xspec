<!DOCTYPE html>

<html>
<head>
  <title>Assertion Contexts</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="xspec.html">
                xspec.rb
              </a>
            
              
              <a class="source" href="assertion_contexts.html">
                assertion_contexts.rb
              </a>
            
              
              <a class="source" href="autorun.html">
                autorun.rb
              </a>
            
              
              <a class="source" href="data_structures.html">
                data_structures.rb
              </a>
            
              
              <a class="source" href="defaults.html">
                defaults.rb
              </a>
            
              
              <a class="source" href="dsl.html">
                dsl.rb
              </a>
            
              
              <a class="source" href="evaluators.html">
                evaluators.rb
              </a>
            
              
              <a class="source" href="notifiers.html">
                notifiers.rb
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="assertion-contexts">Assertion Contexts</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Assertion contexts are composed together into a context stack. The final
stack has a single API method <code>call</code>, which is sent the unit of work to be
executed and must return an array of <code>Failure</code> objects. It should not allow
code-level exceptions to be raised, though should not block system exceptions
(<code>SignalException</code>, <code>NoMemoryError</code>, etc).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">XSpec</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">AssertionContext</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A stack is typically book-ended by the top and bottom contexts, so this
helper is the most commond way to build up a custom stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-keyword">self</span>.stack(&amp;block)
      <span class="hljs-constant">Module</span>.new <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">include</span> <span class="hljs-constant">Bottom</span>
        instance_exec &amp;block
        <span class="hljs-keyword">include</span> <span class="hljs-constant">Top</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The bottom context executes the unit of work, with no error handling or
extra behaviour. By separating this, all other contexts layered on top of
this one can just call <code>super</code>, making them easy to compose.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bottom</span></span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
        instance_exec(&amp;unit_of_work.block)
        []
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The top should be included as the final module in a context stack. It is
a catch all to make sure all standard exceptions have been handled and
do not leak outside the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Top</span></span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
        <span class="hljs-keyword">super</span>
      <span class="hljs-keyword">rescue</span> =&gt; e
        [<span class="hljs-constant">CodeException</span>.new(unit_of_work, e.message, e.backtrace)]
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3 id="simple-assertions">Simple Assertions</h3>
<p>This simple context provides very straight-forward assertion methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Simple</span></span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssertionFailed</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">RuntimeError</span></span></span>
        <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:message</span>, <span class="hljs-symbol">:backtrace</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>initialize(message, backtrace)
          <span class="hljs-variable">@message</span>   = message
          <span class="hljs-variable">@backtrace</span> = backtrace
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
        <span class="hljs-keyword">super</span>
      <span class="hljs-keyword">rescue</span> <span class="hljs-constant">AssertionFailed</span> =&gt; e
        [<span class="hljs-constant">Failure</span>.new(unit_of_work, e.message, e.backtrace)]
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>assert(proposition, message=<span class="hljs-keyword">nil</span>)
        <span class="hljs-keyword">unless</span> proposition
          message ||= <span class="hljs-string">'assertion failed'</span>

          _raise message
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>assert_equal(expected, actual)
        <span class="hljs-keyword">unless</span> expected == actual
          message ||= &lt;&lt;-<span class="hljs-constant">EOS</span>.chomp
<span class="hljs-symbol">want:</span> <span class="hljs-comment">#{expected.inspect}</span>
 <span class="hljs-symbol">got:</span> <span class="hljs-comment">#{actual.inspect}</span>
<span class="hljs-constant">EOS</span>

          _raise message
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>assert_include(expected, output)
        assert output.<span class="hljs-keyword">include</span>?(expected),
          <span class="hljs-string">"<span class="hljs-subst">#{expected.inspect}</span> not present in: <span class="hljs-subst">#{output.inspect}</span>"</span>
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>fail(message = <span class="hljs-keyword">nil</span>)
        message ||= <span class="hljs-string">'failed'</span>

        _raise message
      <span class="hljs-keyword">end</span>

      private

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>_raise(message)
        raise <span class="hljs-constant">AssertionFailed</span>.new(message, caller)
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3 id="doubles">Doubles</h3>
<p>The doubles module provides test doubles that can be used in-place of
real objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Doubles</span></span>
      <span class="hljs-constant">DoubleFailure</span> = <span class="hljs-constant">Class</span>.new(<span class="hljs-constant">RuntimeError</span>)

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
        <span class="hljs-keyword">super</span>
      <span class="hljs-keyword">rescue</span> <span class="hljs-constant">DoubleFailure</span> =&gt; e
        [<span class="hljs-constant">Failure</span>.new(unit_of_work, e.message, e.backtrace)]
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>It can be configured with a few options:</p>
<ul>
<li><code>auto_verify</code> calls <code>assert_exhausted</code> on all created doubles after a
unit of work executes successfully to ensure that all expectations that
were set were actually called.</li>
<li><code>strict</code> forbids doubling of classes that have not been loaded. This
should generally be enabled when doing a full spec run, and disabled
when running specs in isolation.</li>
</ul>
<p>The <code>with</code> method returns a module that can be included in a stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-keyword">self</span>.with(*opts)
        modules = [<span class="hljs-keyword">self</span>] + opts.map {|x| {
          <span class="hljs-symbol">auto_verify:</span> <span class="hljs-constant">AutoVerify</span>,
          <span class="hljs-symbol">strict:</span>      <span class="hljs-constant">Strict</span>
        }.fetch(x) }


        <span class="hljs-constant">Module</span>.new <span class="hljs-keyword">do</span>
          modules.each <span class="hljs-keyword">do</span> |m|
            <span class="hljs-keyword">include</span> m
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>An instance double stands in for an instance of the given class
reference, given as a string. The class does not need to be loaded, but
if it is then only public instance methods defined on the class are
able to be expected.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>instance_double(klass)
        _double(klass, <span class="hljs-constant">InstanceReference</span>)
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Simarly, a class double validates that class responds to all expected
methods, if that class has been loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>class_double(klass)
        _double(klass, <span class="hljs-constant">ClassReference</span>)
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>If the doubled class has not been loaded, a null object reference is
used that allows expecting of all methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>_double(klass, type)
        ref = <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-keyword">class</span>.const_defined?(klass)
          type.new(<span class="hljs-keyword">self</span>.<span class="hljs-keyword">class</span>.const_get(klass))
        <span class="hljs-keyword">else</span>
          <span class="hljs-constant">StringReference</span>.new(klass)
        <span class="hljs-keyword">end</span>

        <span class="hljs-constant">Double</span>.new(ref)
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>To set up an expectation on a double, call the expected method an
arguments on the proxy object returned by <code>expect</code>. If a return value
is desired, it can be supplied as a block, for example:
<code>expect(double).some_method(1, 2) { &quot;return value&quot; }</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>expect(obj)
        <span class="hljs-constant">Recorder</span>.new(obj)
      <span class="hljs-keyword">end</span>

      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recorder</span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>initialize(double)
          <span class="hljs-variable">@double</span> = double
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>method_missing(*args, &amp;ret)
          <span class="hljs-variable">@double</span>._expect(args, &amp;(ret || -&gt;{}))
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Since the double object inherits from <code>BasicObject</code>, virtually every
method call will be routed through <code>method_missing</code>. From there, the
call can be checked against the expectations that were setup at the
beginning of a spec.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Double</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">BasicObject</span></span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>initialize(klass)
          <span class="hljs-variable">@klass</span>    = klass
          <span class="hljs-variable">@expected</span> = []
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>method_missing(*actual_args)
          i = <span class="hljs-variable">@expected</span>.find_index {|expected_args, ret|
            expected_args == actual_args
          }

          <span class="hljs-keyword">if</span> i
            <span class="hljs-variable">@expected</span>.delete_at(i)[<span class="hljs-number">1</span>].call
          <span class="hljs-keyword">else</span>
            name, rest = *actual_args
            <span class="hljs-constant">::Kernel</span>.raise <span class="hljs-constant">DoubleFailure</span>, <span class="hljs-string">"Unexpectedly received: %s(%s)"</span> % [
              name,
              [*rest].map(&amp;<span class="hljs-symbol">:inspect</span>).join(<span class="hljs-string">", "</span>)
            ]
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The two methods needed on this object to set it up and verify it are
prefixed by <code>_</code> to try to ensure they don’t clash with any method
expectations. While not fail-safe, users should only be using
expectations for a public API, and <code>_</code> is traditionally only used
for private methods (if at all).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>_expect(args, &amp;ret)
          <span class="hljs-variable">@klass</span>.validate_call! args

          <span class="hljs-variable">@expected</span> &lt;&lt; [args, ret]
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>_verify
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">@expected</span>.empty?

          <span class="hljs-constant">::Kernel</span>.raise <span class="hljs-constant">DoubleFailure</span>, <span class="hljs-string">"%s double did not receive:\n%s"</span> % [
            <span class="hljs-variable">@klass</span>.to_s,
            <span class="hljs-variable">@expected</span>.map {|(name, *args), <span class="hljs-number">_</span>|
              <span class="hljs-string">"  %s(%s)"</span> % [name, args.map(&amp;<span class="hljs-symbol">:inspect</span>).join(<span class="hljs-string">", "</span>)]
            }.join(<span class="hljs-string">"\n"</span>)
          ]
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>A reference can be thought of as a “backing object” for a double. It
provides an API to validate that a method being expected actually
exists - the implementation is different for the different types of
doubles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>initialize(klass)
          <span class="hljs-variable">@klass</span> = klass
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>validate_call!(args)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>to_s
          <span class="hljs-variable">@klass</span>.to_s
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>A string reference is the “null object” of references, allowing all
methods to be expected. It is used when nothing is known about the
referenced class (such as when it has not been loaded).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringReference</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">Reference</span></span></span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Class and Instance references are backed by loaded classes, and
restrict the messages that can be expected on a double.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassReference</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">Reference</span></span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>validate_call!(args)
          name, rest = *args

          <span class="hljs-keyword">unless</span> <span class="hljs-variable">@klass</span>.respond_to?(name)
            raise <span class="hljs-constant">DoubleFailure</span>,
              <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-variable">@klass</span>}</span>.<span class="hljs-subst">#{name}</span> is unimplemented or not public"</span>
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>

      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceReference</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">Reference</span></span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>validate_call!(args)
          name, rest = *args

          <span class="hljs-keyword">unless</span> <span class="hljs-variable">@klass</span>.public_instance_methods.<span class="hljs-keyword">include</span>?(name)
            raise <span class="hljs-constant">DoubleFailure</span>,
              <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-variable">@klass</span>}</span>#<span class="hljs-subst">#{name}</span> is unimplemented or not public"</span>
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The <code>:strict</code> option mixes in this <code>Strict</code> module, which raises rather
than create <code>StringReference</code>s for unknown classes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Strict</span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>_double(klass, type)
          ref = <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-keyword">class</span>.const_defined?(klass)
            type.new(<span class="hljs-keyword">self</span>.<span class="hljs-keyword">class</span>.const_get(klass))
          <span class="hljs-keyword">else</span>
            raise <span class="hljs-constant">DoubleFailure</span>, <span class="hljs-string">"<span class="hljs-subst">#{klass}</span> is not a valid class name"</span>
          <span class="hljs-keyword">end</span>

          <span class="hljs-keyword">super</span>
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>An assertion is provided to validate that all expected methods were
called on a double.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>assert_exhausted(obj)
        obj._verify
      <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Most of the time, <code>assert_exhausted</code> will not be called directly, since
the <code>:auto_verify</code> option can be used to call it by default on all
doubles. That option mixes in this <code>AutoVerify</code> module to augment
methods necessary for this behaviour.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">AutoVerify</span></span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>initialize
          <span class="hljs-variable">@doubles</span> = []
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
          result = <span class="hljs-keyword">super</span>

          <span class="hljs-keyword">if</span> result.empty?
            <span class="hljs-variable">@doubles</span>.each <span class="hljs-keyword">do</span> |double|
              assert_exhausted double
            <span class="hljs-keyword">end</span>
          <span class="hljs-keyword">end</span>

          result
        <span class="hljs-keyword">rescue</span> <span class="hljs-constant">DoubleFailure</span> =&gt; e
          [<span class="hljs-constant">Failure</span>.new(unit_of_work, e.message, e.backtrace)]
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>class_double(klass)
          x = <span class="hljs-keyword">super</span>
          <span class="hljs-variable">@doubles</span> &lt;&lt; x
          x
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> </span>instance_double(klass)
          x = <span class="hljs-keyword">super</span>
          <span class="hljs-variable">@doubles</span> &lt;&lt; x
          x
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h3 id="rspec-integration">RSpec Integration</h3>
<p>This RSpec adapter shows two useful techniques: dynamic library loading
which removes RSpec as a direct dependency, and use of the <code>mixin</code>
method to further extend the target context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">RSpecExpectations</span></span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> </span><span class="hljs-keyword">self</span>.included(context)
        <span class="hljs-keyword">begin</span>
          <span class="hljs-keyword">require</span> <span class="hljs-string">'rspec/expectations'</span>
          <span class="hljs-keyword">require</span> <span class="hljs-string">'rspec/matchers'</span>
        <span class="hljs-keyword">rescue</span> <span class="hljs-constant">LoadError</span>
          raise <span class="hljs-string">"RSpec is not available, cannot use RSpec assertion context."</span>
        <span class="hljs-keyword">end</span>

        context.<span class="hljs-keyword">include</span>(<span class="hljs-constant">RSpec::Matchers</span>)
      <span class="hljs-keyword">end</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> </span>call(unit_of_work)
        <span class="hljs-keyword">super</span>
      <span class="hljs-keyword">rescue</span> <span class="hljs-constant">RSpec::Expectations::ExpectationNotMetError</span> =&gt; e
        [<span class="hljs-constant">Failure</span>.new(unit_of_work, e.message, e.backtrace)]
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-constant">DEFAULT</span> = stack <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">include</span> <span class="hljs-constant">Simple</span>
      <span class="hljs-keyword">include</span> <span class="hljs-constant">Doubles</span>.with(<span class="hljs-symbol">:auto_verify</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
