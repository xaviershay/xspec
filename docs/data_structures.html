<!DOCTYPE html>

<html>
<head>
  <title>data_structures.rb</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="assertion_contexts.html">
                assertion_contexts.rb
              </a>
            
              
              <a class="source" href="autorun.html">
                autorun.rb
              </a>
            
              
              <a class="source" href="data_structures.html">
                data_structures.rb
              </a>
            
              
              <a class="source" href="defaults.html">
                defaults.rb
              </a>
            
              
              <a class="source" href="dsl.html">
                dsl.rb
              </a>
            
              
              <a class="source" href="evaluators.html">
                evaluators.rb
              </a>
            
              
              <a class="source" href="notifiers.html">
                notifiers.rb
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>data_structures.rb</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>XSpec data structures are very dumb. They:</p>
<ul>
<li>Only contain iteration and creation logic.</li>
<li>Do not store recursive references (&quot;everything flows downhill&quot;).</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">module</span> <span class="title">XSpec</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A unit of work, usually created by the <code>it</code> DSL method, is a labeled,
indivisible code block that expresses an assertion about a property of the
system under test. They are run by an evaluator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="constant">UnitOfWork</span> = <span class="constant">Struct</span>.new(<span class="symbol">:name</span>, <span class="symbol">:block</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A context is a recursively nested structure, usually created with the
<code>describe</code> DSL method, that contains other contexts and units of work. Most
of the logic for a context happens at the class level rather than instance,
which is unusual but required for method inheritance to work correctly. It
currently violates the logic rule specified above, more work is required to
decouple it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">require</span> <span class="string">'xspec/dsl'</span>
  <span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>
    <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span><span class="inheritance">&lt; <span class="parent">self</span></span></span>
      attr_reader <span class="symbol">:name</span>, <span class="symbol">:children</span>, <span class="symbol">:units_of_work</span>, <span class="symbol">:assertion_context</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>A context includes the same DSL methods as the root level module, which
enables the recursive creation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">__xspec_context</span>;</span> <span class="keyword">self</span>; <span class="keyword">end</span>
      <span class="keyword">include</span> <span class="constant">::XSpec::DSL</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Each nested context creates a new class that inherits from the parent.
Methods can be added to this class as per normal, and are correctly
inherited by children. When it comes time to run tests, the evaluator will
create a new instance of the context (a class) for each test, making the
defined methods available and also ensuring that there is no state
pollution between tests.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(name, assertion_context, &amp;block)</span></span>
        x = <span class="constant">Class</span>.new(<span class="keyword">self</span>)
        x.initialize!(name, assertion_context)
        x.class_eval(&amp;block) <span class="keyword">if</span> block
        x.apply_assertion_context!
        x
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A class cannot have an implicit initializer, but some variable
inititialization is required so the <code>initialize!</code> method is called
explicitly when ever a dynamic subclass is created.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">initialize!</span><span class="params">(name, assertion_context)</span></span>
        <span class="variable">@children</span>          = []
        <span class="variable">@units_of_work</span>     = []
        <span class="variable">@name</span>              = name
        <span class="variable">@assertion_context</span> = assertion_context
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The assertion context should be applied after the user has had a chance
to add their own methods. It needs to be last so that users can&#39;t
clobber the assertion methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">apply_assertion_context!</span></span>
        mixin(assertion_context)
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Executing a unit of work creates a new instance and hands it off to the
<code>call</code> method, which is defined by whichever assertion context is being
used. By creating a new instance everytime, no state is preserved
between executions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(unit_of_work)</span></span>
        new.call(unit_of_work)
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The root context is nothing special, and behaves the same as all the
others.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(assertion_context)</span></span>
        make(<span class="keyword">nil</span>, assertion_context)
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Child contexts and units of work are typically added by the <code>describe</code>
and <code>it</code> DSL methods respectively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">add_child_context</span><span class="params">(name = <span class="keyword">nil</span>, opts = {}, &amp;block)</span></span>
        <span class="keyword">self</span>.children &lt;&lt; make(name, assertion_context, &amp;block)
      <span class="keyword">end</span>

      <span class="function"><span class="keyword">def</span> <span class="title">add_unit_of_work</span><span class="params">(name = <span class="keyword">nil</span>, opts = {}, &amp;block)</span></span>
        <span class="keyword">self</span>.units_of_work &lt;&lt; <span class="constant">UnitOfWork</span>.new(name, block)
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A shared context is a floating context that isn&#39;t part of any context
heirachy, so its units of work will not be visible to the root node. It
can be brought into any point in the heirachy using <code>copy_into_tree</code>
(aliased as <code>it_behaves_like_a</code> in the DSL), and this can be done
multiple times, which allows definitions to be reused.</p>
<p>This is leaky abstraction, since only units of work are copied from
shared contexts. Methods and child contexts are ignored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">create_shared_context</span><span class="params">(&amp;block)</span></span>
        make(<span class="keyword">nil</span>, assertion_context, &amp;block)
      <span class="keyword">end</span>

      <span class="function"><span class="keyword">def</span> <span class="title">copy_into_tree</span><span class="params">(source_context)</span></span>
        target_context = make(
          source_context.name,
          source_context.assertion_context
        )
        source_context.nested_units_of_work.each <span class="keyword">do</span> |x|
          target_context.units_of_work &lt;&lt; x.unit_of_work
        <span class="keyword">end</span>
        <span class="keyword">self</span>.children &lt;&lt; target_context
        target_context
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The most convenient way to access all units of work is this recursive
iteration that returns all leaf-nodes as <code>NestedUnitOfWork</code> objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">require</span> <span class="string">'enumerator'</span>
      <span class="function"><span class="keyword">def</span> <span class="title">nested_units_of_work</span><span class="params">(&amp;block)</span></span>
        enum = <span class="constant">Enumerator</span>.new <span class="keyword">do</span> |y|
          children.each <span class="keyword">do</span> |child|
            child.nested_units_of_work <span class="keyword">do</span> |x|
              y.<span class="keyword">yield</span> x.nest_under(<span class="keyword">self</span>)
            <span class="keyword">end</span>
          <span class="keyword">end</span>

          units_of_work.each <span class="keyword">do</span> |x|
            y.<span class="keyword">yield</span> <span class="constant">NestedUnitOfWork</span>.new([<span class="keyword">self</span>], x)
          <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">if</span> block
          enum.each(&amp;block)
        <span class="keyword">else</span>
          enum
        <span class="keyword">end</span>
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>include</code> is normally private, but it is useful to allow other classes
and modules to include additional behaviour (such as assertion
contexts).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">mixin</span><span class="params">(mod)</span></span>
        <span class="keyword">include</span>(mod)
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Values of memoized methods are remembered only for the duration of a
single unit of work. These are typically creates using the <code>let</code> DSL
method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">add_memoized_method</span><span class="params">(name, &amp;block)</span></span>
        define_method(name) <span class="keyword">do</span>
          memoized[block] ||= instance_eval(&amp;block)
        <span class="keyword">end</span>
      <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Dynamically generated classes are hard to identify in object graphs, so
it is helpful for debugging to set an explicit name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span>
        <span class="string">"Context:'<span class="subst">#{name}</span>'"</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    attr_reader <span class="symbol">:memoized</span>

    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>
      <span class="variable">@memoized</span> = {}
    <span class="keyword">end</span>
  <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Units of work can be nested inside contexts. This is the main object that
other components of the system work with.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="constant">NestedUnitOfWork</span> = <span class="constant">Struct</span>.new(<span class="symbol">:parents</span>, <span class="symbol">:unit_of_work</span>) <span class="keyword">do</span>
    <span class="function"><span class="keyword">def</span> <span class="title">block</span>;</span> unit_of_work.block; <span class="keyword">end</span>
    <span class="function"><span class="keyword">def</span> <span class="title">name</span>;</span>  unit_of_work.name; <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">immediate_parent</span></span>
      parents.last
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">nest_under</span><span class="params">(parent)</span></span>
      <span class="keyword">self</span>.<span class="keyword">class</span>.new([parent] + parents, unit_of_work)
    <span class="keyword">end</span>
  <span class="keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>A test failure will be reported as a <code>Failure</code>, which includes contextual
information about the failure useful for reporting to the user.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="constant">Failure</span> = <span class="constant">Struct</span>.new(<span class="symbol">:unit_of_work</span>, <span class="symbol">:message</span>, <span class="symbol">:caller</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>An exception is mostly handled the same was as a failure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="constant">CodeException</span> = <span class="constant">Class</span>.new(<span class="constant">Failure</span>)
<span class="keyword">end</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
